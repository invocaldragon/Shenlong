<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Esferas Místicas</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background-color: #111;
      color: white;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    h1 {
      margin: 20px;
    }
    .controls {
      margin-bottom: 10px;
    }
    .controls button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    .slow { background-color: #4CAF50; color: white; }
    .normal { background-color: #2196F3; color: white; }
    .fast { background-color: #f44336; color: white; }
    canvas {
      border: 2px solid #fff;
      background-color: #000;
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <h1>Reúne las Esferas del Dragón</h1>
  <div class="controls">
    <button class="slow" onclick="setSpeed(0.5)">Lento</button>
    <button class="normal" onclick="setSpeed(2)">Normal</button>
    <button class="fast" onclick="setSpeed(4)">Rápido</button>
  </div>
  <canvas id="gameCanvas" width="350" height="500"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const totalEsferas = 7;
    const radius = 30;
    let speedMultiplier = 1;

    class DragonBall {
      constructor(x, y, number, img) {
        this.x = x;
        this.y = y;
        this.number = number;
        this.radius = radius;
        this.vx = (Math.random() * 2 - 1) * speedMultiplier;
        this.vy = (Math.random() * 2 - 1) * speedMultiplier;
        this.stopped = false;
        this.img = img;
      }

      draw() {
        ctx.drawImage(this.img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      }

      update() {
        if (this.found) return; // Si ya fue encontrada, no hacer nada
      
        this.x += this.vx * speedMultiplier;
        this.y += this.vy * speedMultiplier;
      
        const leftLimit = this.radius + 2;
        const rightLimit = canvas.width - this.radius - 2;
        const topLimit = this.radius + 2;
        const bottomLimit = canvas.height - this.radius - 2;
      
        if (this.x < leftLimit) {
          this.x = leftLimit;
          this.vx *= -1;
        }
        if (this.x > rightLimit) {
          this.x = rightLimit;
          this.vx *= -1;
        }
        if (this.y < topLimit) {
          this.y = topLimit;
          this.vy *= -1;
        }
        if (this.y > bottomLimit) {
          this.y = bottomLimit;
          this.vy *= -1;
        }
      }




      checkCollision(other) {
        if (this.stopped && other.stopped) return;

        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const distance = Math.hypot(dx, dy);

        if (distance < this.radius * 2) {
          const tempVx = this.vx;
          const tempVy = this.vy;
          this.vx = other.vx;
          this.vy = other.vy;
          other.vx = tempVx;
          other.vy = tempVy;
        }
      }

      isClicked(x, y) {
        return Math.hypot(this.x - x, this.y - y) < this.radius;
      }
    }

    let esferas = [];
    let imagesLoaded = 0;
    let currentNumber = 1;

    function isOverlapping(x, y, existingEsferas) {
      return existingEsferas.some(e => {
        const dx = x - e.x;
        const dy = y - e.y;
        const distance = Math.hypot(dx, dy);
        return distance < radius * 2;
      });
    }

    function generateNonOverlappingPosition(existingEsferas) {
      let x, y, attempts = 0;
      do {
        x = Math.random() * (canvas.width - 2 * radius) + radius;
        y = Math.random() * (canvas.height - 2 * radius) + radius;
        attempts++;
      } while (isOverlapping(x, y, existingEsferas) && attempts < 1000);
      return { x, y };
    }

    function loadImagesAndStart() {
      for (let i = 1; i <= totalEsferas; i++) {
        const img = new Image();
        img.src = `esfera${i}.png`;
        img.onload = () => {
          imagesLoaded++;
          if (imagesLoaded === totalEsferas) {
            startGame();
          }
        };
        const { x, y } = generateNonOverlappingPosition(esferas);
        esferas.push(new DragonBall(x, y, i, img));
      }
    }

    function startGame() {
      requestAnimationFrame(updateGame);
    }

    function updateGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      esferas.forEach(e => e.update());
      for (let i = 0; i < esferas.length; i++) {
        for (let j = i + 1; j < esferas.length; j++) {
          esferas[i].checkCollision(esferas[j]);
        }
      }
      esferas.forEach(e => e.draw());

      requestAnimationFrame(updateGame);
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const clicked = esferas.find(esf => !esf.stopped && esf.isClicked(mouseX, mouseY));

      if (clicked && clicked.number === currentNumber) {
        clicked.stopped = true;
        clicked.vx = 0;
        clicked.vy = 0;
        currentNumber++;
        if (currentNumber > totalEsferas) {
          alert("¡Has reunido todas las esferas!");
        }
      }
    });

    function setSpeed(multiplier) {
      speedMultiplier = multiplier;
      esferas.forEach(esf => {
        if (!esf.stopped) {
          esf.vx = (Math.random() * 2 - 1) * speedMultiplier;
          esf.vy = (Math.random() * 2 - 1) * speedMultiplier;
        }
      });
    }

    loadImagesAndStart();
  </script>
</body>
</html>
