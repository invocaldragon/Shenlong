<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Esferas del Dragón en Movimiento</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background-color: #111;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    canvas {
      border: 3px solid #ff9800;
      border-radius: 10px;
      background-color: black;
    }
    .controls {
      margin-top: 10px;
    }
    .controls button {
      margin: 0 5px;
      padding: 8px 16px;
      font-size: 14px;
      background-color: #ff9800;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .controls button:hover {
      background-color: #e68900;
    }
    #instructions {
      margin: 20px;
      font-size: 18px;
      text-align: center;
    }
  </style>
</head>
<body>

  <h1>Reúne las Esferas del Dragón</h1>
  <div id="instructions">Selecciona las esferas en orden de la 1 a la 7.</div>

  <canvas id="gameCanvas" width="360" height="540"></canvas>

  <div class="controls">
    <button onclick="setSpeed(0.5)">Lento</button>
    <button onclick="setSpeed(1)">Normal</button>
    <button onclick="setSpeed(2)">Rápido</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const sphereRadius = 30;
    const margin = 2;
    let speedMultiplier = 1;

    let currentStep = 1;
    let spheres = [];

    // Cargar imágenes
    const images = [];
    for (let i = 1; i <= 7; i++) {
      const img = new Image();
      img.src = `esfera${i}.png`;
      images.push(img);
    }

    class DragonBall {
      constructor(x, y, number) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() * 2 - 1) * 2;
        this.vy = (Math.random() * 2 - 1) * 2;
        this.number = number;
        this.radius = sphereRadius;
        this.found = false;
        this.image = images[number - 1];
      }

      update() {
        if (this.found) return;

        this.x += this.vx * speedMultiplier;
        this.y += this.vy * speedMultiplier;

        const leftLimit = this.radius + margin;
        const rightLimit = canvas.width - this.radius - margin;
        const topLimit = this.radius + margin;
        const bottomLimit = canvas.height - this.radius - margin;

        if (this.x < leftLimit) {
          this.x = leftLimit;
          this.vx *= -1;
        }
        if (this.x > rightLimit) {
          this.x = rightLimit;
          this.vx *= -1;
        }
        if (this.y < topLimit) {
          this.y = topLimit;
          this.vy *= -1;
        }
        if (this.y > bottomLimit) {
          this.y = bottomLimit;
          this.vy *= -1;
        }
      }

      draw() {
        ctx.drawImage(this.image, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      }

      isInside(mx, my) {
        return Math.hypot(mx - this.x, my - this.y) <= this.radius;
      }
    }

    function generateSpheres() {
      const newSpheres = [];

      for (let i = 1; i <= 7; i++) {
        let valid = false, x, y;
        while (!valid) {
          x = Math.random() * (canvas.width - 2 * (sphereRadius + margin)) + (sphereRadius + margin);
          y = Math.random() * (canvas.height - 2 * (sphereRadius + margin)) + (sphereRadius + margin);
          valid = true;
          for (const s of newSpheres) {
            const dx = s.x - x;
            const dy = s.y - y;
            if (Math.hypot(dx, dy) < sphereRadius * 2 + 4) {
              valid = false;
              break;
            }
          }
        }
        newSpheres.push(new DragonBall(x, y, i));
      }
      return newSpheres;
    }

    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const s of spheres) {
        s.update();
        s.draw();
      }
      requestAnimationFrame(drawAll);
    }

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      for (const s of spheres) {
        if (!s.found && s.isInside(mx, my)) {
          if (s.number === currentStep) {
            s.found = true;
            s.vx = 0;
            s.vy = 0;
            currentStep++;
            document.getElementById("instructions").textContent = `¡Correcto! Ahora busca la esfera ${currentStep}.`;
            if (currentStep > 7) {
              document.getElementById("instructions").textContent = "¡Has reunido todas las esferas!";
            }
          } else {
            document.getElementById("instructions").textContent = `Esa no es. Busca la esfera ${currentStep}.`;
          }
          break;
        }
      }
    });

    function setSpeed(factor) {
      speedMultiplier = factor;
    }

    function startGame() {
      spheres = generateSpheres();
      drawAll();
    }

    // Esperar a que las imágenes carguen antes de iniciar
    Promise.all(images.map(img => new Promise(res => img.onload = res))).then(startGame);
  </script>

</body>
</html>
